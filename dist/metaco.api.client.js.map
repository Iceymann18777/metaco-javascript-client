{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","lib/MetacoClientBuilder.js","lib/MetacoClientBuilderFactory.js","lib/client/MetacoClient.js","lib/errors/ErrorHandler.js","lib/errors/MetacoErrors.js","lib/http/BrowserHttpClient.js","lib/index_browser.js","lib/utils/Extensions.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"metaco.api.client.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var MetacoClient = require(\"./client/MetacoClient\");\r\n\r\nfunction MetacoClientBuilder(HttpClient) {\r\n    this.HttpClient = HttpClient;\r\n}\r\n\r\nMetacoClientBuilder.prototype.withApiUrl = function(apiUrl) {\r\n    this.metacoApiUrl = apiUrl;\r\n    return this;\r\n};\r\n\r\nMetacoClientBuilder.prototype.withApiId = function(apiId) {\r\n    this.metacoApiId = apiId;\r\n    return this;\r\n};\r\n\r\nMetacoClientBuilder.prototype.withApiKey = function(apiKey) {\r\n    this.metacoApiKey = apiKey;\r\n    return this;\r\n};\r\n\r\nMetacoClientBuilder.prototype.withTestingMode = function(testingMode) {\r\n    this.metacoTestingMode = testingMode;\r\n    return this;\r\n};\r\n\r\nMetacoClientBuilder.prototype.makeClient = function() {\r\n    return new MetacoClient(this.HttpClient, this.metacoApiUrl, this.metacoApiId, this.metacoApiKey, this.metacoTestingMode);\r\n};\r\n\r\nmodule.exports = MetacoClientBuilder;","var MetacoClientBuilder = require(\"./MetacoClientBuilder\");\r\n\r\nfunction MetacoClientBuilderFactory() {}\r\n\r\nMetacoClientBuilderFactory.prototype.makeClientBuilderWithHttpClient = function(httpClient) {\r\n    return new MetacoClientBuilder(httpClient);\r\n};\r\n\r\nmodule.exports = MetacoClientBuilderFactory;","var extensions = require(\"../utils/Extensions\");\r\n\r\nfunction MetacoClient(HttpClient, metacoApiUrl, metacoApiId, metacoApiKey, metacoTestingMode) {\r\n    this.metacoApiId = metacoApiId;\r\n    this.metacoApiKey = metacoApiKey;\r\n    this.metacoApiUrl = metacoApiUrl;\r\n    this.metacoTestingMode = metacoTestingMode;\r\n\r\n    this.httpClient = new HttpClient(this.metacoApiUrl, this.metacoApiId, this.metacoApiKey, this.metacoTestingMode);\r\n}\r\n\r\n/**\r\n * The general request callback for our methods\r\n *\r\n * @callback requestCallback\r\n * @param {object} errorDetails - Contains all the error details\r\n * @param {object} responseObject - The data object returned from the API\r\n */\r\n\r\n/**\r\n * Register an account on Metaco\r\n * Sends an SMS to the provided phone number\r\n * Returns the API ID and API Keys\r\n *\r\n * If you are in debug mode, this request will return a HTTP header X-Metaco-DebugData with the validation code, it won't be send by SMS\r\n *\r\n * @see {@link http://docs.metaco.apiary.io/#reference/account/account-management/register-an-account} our online documentation.\r\n * @param {string} phoneNumber - The account phone number (E164 format)\r\n * @param {requestCallback} callback - The callback that handles the response\r\n */\r\nMetacoClient.prototype.registerAccount = function(phoneNumber, callback) {\r\n    var registerRequest = {\r\n        phone: phoneNumber\r\n    };\r\n    this.httpClient.doPost(\"account\", registerRequest, callback);\r\n};\r\n\r\n/**\r\n * Requires Authentication\r\n * Returns the details of an account (API Id, KYC Status and remaining trading amount)\r\n *\r\n * @see {@link http://docs.metaco.apiary.io/#reference/account/account-management/get-account-status} our online documentation.\r\n * @param {requestCallback} callback - The callback that handles the response\r\n */\r\nMetacoClient.prototype.getAccountStatus = function(callback) {\r\n    this.httpClient.doGet(\"account\", callback);\r\n};\r\n\r\n/**\r\n * Requires Authentication\r\n * Validate the authenticated account, returns an error if there is a problem\r\n *\r\n * @see {@link http://docs.metaco.apiary.io/#reference/account/account-management/confirm-a-phone-number} our online documentation.\r\n * @param {string} code - The validation code sent by SMS (returned as header in debug mode)\r\n * @param {requestCallback} callback - The callback that handles the response\r\n */\r\nMetacoClient.prototype.confirmPhoneNumber = function(code, callback) {\r\n    var confirmRequest = {\r\n        code: code\r\n    };\r\n    this.httpClient.doPost(\"account/confirmation\", confirmRequest, callback);\r\n};\r\n\r\n/**\r\n * Returns all the available Assets and their details\r\n *\r\n * @see {@link http://docs.metaco.apiary.io/#reference/assets/assets-list/list-all-assets} our online documentation.\r\n * @param {requestCallback} callback - The callback that handles the response\r\n */\r\nMetacoClient.prototype.getAssets = function(callback) {\r\n    this.httpClient.doGet(\"assets\", callback);\r\n};\r\n\r\n/**\r\n * Returns the selected Asset if it exists and its details\r\n *\r\n * @see {@link http://docs.metaco.apiary.io/#reference/assets/asset-information/retrieve-an-asset} our online documentation.\r\n * @param {string} ticker - The full ticker identifier (MTC:USD) of the requested asset\r\n * @param {requestCallback} callback - The callback that handles the response\r\n */\r\nMetacoClient.prototype.getAsset = function(ticker, callback) {\r\n    this.httpClient.doGet(extensions.formatString(\"assets/{0}\", ticker), callback);\r\n};\r\n\r\n/**\r\n * Returns the history for the provided assets according to the given criteria\r\n * Assets must be given using this format : USD,XAU,etc..\r\n *\r\n * @see {@link http://docs.metaco.apiary.io/#reference/assets/assets-history/retrieve-history-of-all-assets} our online documentation.\r\n * @param {number} from - Timestamp from used for history start date.\r\n * @param {number} to - Timestamp to used for history end date.\r\n * @param {string} freq - Frequency freq of the history (for instance, 1m or 1d).\r\n * @param {boolean} asc - Ordering of the values.\r\n * @param {string|string[]} underlyings - The list of the required assets (comma separated string or array), identified by their underlyings (ex : MTC:USD -> USD)\r\n * @param {requestCallback} callback - The callback that handles the response\r\n */\r\nMetacoClient.prototype.getAssetsHistory = function(from, to, freq, asc, underlyings, callback) {\r\n    var tickerStr = \"\";\r\n    if (underlyings == null) {\r\n        tickerStr = \"all\";\r\n    } else if (typeof(underlyings) !== \"string\") {\r\n        for (var i = 0; i < underlyings.length; i++) {\r\n            tickerStr += underlyings[i];\r\n            if (i < underlyings.length - 1) {\r\n                tickerStr += \",\";\r\n            }\r\n        }\r\n    } else {\r\n        tickerStr = underlyings;\r\n    }\r\n\r\n    var url = extensions.formatString(\"assets/history?underlyings={0}&from={1}&to={2}&freq={3}&orderAsc={4}\", tickerStr, from, to, freq, asc);\r\n\r\n    this.httpClient.doGet(url, callback);\r\n\r\n};\r\n\r\n/**\r\n * Returns the history for the provided asset according to the given criteria\r\n * Assets must be given using this format : USD,XAU,etc..\r\n *\r\n * @see {@link http://docs.metaco.apiary.io/#reference/assets/assets-history/retrieve-history-of-all-assets} our online documentation.\r\n * @param {number} from - Timestamp from used for history start date.\r\n * @param {number} to - Timestamp to used for history end date.\r\n * @param {string} freq - Frequency freq of the history (for instance, 1m or 1d).\r\n * @param {boolean} asc - Ordering of the values.\r\n * @param {string|string[]} underlying - The required asset, identified by its underlying (ex : MTC:USD -> USD)\r\n * @param {requestCallback} callback - The callback that handles the response\r\n */\r\nMetacoClient.prototype.getAssetHistory = function(from, to, freq, asc, underlying, callback) {\r\n    this.getAssetsHistory(from, to, freq, asc, underlying, callback);\r\n};\r\n\r\n/**\r\n * Requires Authentication\r\n * Create an order using the provided parameters\r\n * This order will be created using the satoshi amount of the specified asset, this means that amountSatoshi is always satoshi-denominated. If you want 199000000 satoshi of USD then amountSatoshi is 199000000.\r\n * This order will be processed in our system\r\n * It will require your signature later when the trade state will be Signing\r\n *\r\n * @see {@link http://docs.metaco.apiary.io/#reference/orders/orders-management/request-an-order} our online documentation.\r\n * @param {string} type - Type of the order buy/sell or ask/bid\r\n * @param {string} ticker - The full ticker identifier (MTC:USD) of the requested asset\r\n * @param {number} amountSatoshi - Amount of the order in satoshi.\r\n * @param {string} recipientAddress - This address will receive the order, it will be used as default for the funding and change if they are not provided.\r\n * @param {string|string[]} fundingAddresses - (Optional, use null if you don't want to use it) This address will be used to set the order's funds if provided (Can be a string or a string array).\r\n * @param {string} changeAddress - (Optional, use null if you don't want to use it) This address will receive the change of the order if provided.\r\n * @param {string} webhookUrl - (Optional, use null if you don't want to use it) The webhook is an url called when the order's state is changing. (for example, { \"apiId\" : \"...\", \"orderId\" : \"id\", \"state\" : \"Signing\" }).\r\n * @param {requestCallback} callback - The callback that handles the response\r\n */\r\nMetacoClient.prototype.createOrderFromSatoshiAmount = function(type, ticker, amountSatoshi, recipientAddress, fundingAddresses, changeAddress, webhookUrl, callback) {\r\n    var fundingAddressesArray = [];\r\n    if (typeof(fundingAddresses) === \"string\") {\r\n        fundingAddressesArray.push(fundingAddresses);\r\n    } else {\r\n        fundingAddressesArray = fundingAddresses;\r\n    }\r\n\r\n    var order = {\r\n        \"ticker\": ticker,\r\n        \"amount_satoshi\": amountSatoshi,\r\n        \"recipient\": recipientAddress,\r\n        \"funding\": fundingAddressesArray,\r\n        \"change\": changeAddress,\r\n        \"type\": type,\r\n        \"webhook\": webhookUrl\r\n    };\r\n\r\n    this.httpClient.doPost(\"orders\", order, callback);\r\n};\r\n\r\n/**\r\n * Requires Authentication\r\n * Create an order using the provided parameters\r\n * This order will be created using the asset amount of the specified asset, this means that amountAsset an integer based on the divisibility of the asset as specified by v1/assets. (for example, USD divisibility is 2, if you want to buy 5 USD, then amountAsset should be equal to 500). If you want to buy 5 USD then amountAsset is 500.\r\n * This order will be processed in our system\r\n * It will require your signature later when the trade state will be Signing\r\n *\r\n * @see {@link http://docs.metaco.apiary.io/#reference/orders/orders-management/request-an-order} our online documentation.\r\n * @param {string} type - Type of the order buy/sell or ask/bid\r\n * @param {string} ticker - The full ticker identifier (MTC:USD) of the requested asset\r\n * @param {number} amountAsset - Amount of the order in asset value.\r\n * @param {string} recipientAddress - This address will receive the order, it will be used as default for the funding and change if they are not provided.\r\n * @param {string|string[]} fundingAddresses - (Optional, use null if you don't want to use it) This(those) address(addresses) will be used to set the order's funds if provided (Can be a string or a string array).\r\n * @param {string} changeAddress - (Optional, use null if you don't want to use it) This address will receive the change of the order if provided.\r\n * @param {string} webhookUrl - (Optional, use null if you don't want to use it) The webhook is an url called when the order's state is changing. (for example, { \"apiId\" : \"...\", \"orderId\" : \"id\", \"state\" : \"Signing\" }).\r\n * @param {requestCallback} callback - The callback that handles the response\r\n */\r\nMetacoClient.prototype.createOrderFromAssetAmount = function(type, ticker, amountAsset, recipientAddress, fundingAddresses, changeAddress, webhookUrl, callback) {\r\n    var fundingAddressesArray = [];\r\n    if (typeof(fundingAddresses) === \"string\") {\r\n        fundingAddressesArray.push(fundingAddresses);\r\n    } else {\r\n        fundingAddressesArray = fundingAddresses;\r\n    }\r\n\r\n    var order = {\r\n        \"ticker\": ticker,\r\n        \"amount_asset\": amountAsset,\r\n        \"recipient\": recipientAddress,\r\n        \"funding\": fundingAddressesArray,\r\n        \"change\": changeAddress,\r\n        \"type\": type,\r\n        \"webhook\": webhookUrl\r\n    };\r\n\r\n    this.httpClient.doPost(\"orders\", order, callback);\r\n};\r\n\r\n/**\r\n * Requires Authentication\r\n * Returns the user's orders\r\n *\r\n * @see {@link http://docs.metaco.apiary.io/#reference/orders/orders-management/list-all-orders} our online documentation.\r\n * @param {requestCallback} callback - The callback that handles the response\r\n */\r\nMetacoClient.prototype.getOrders = function(callback) {\r\n    this.httpClient.doGet(\"orders\", callback);\r\n};\r\n\r\n/**\r\n * Requires Authentication\r\n * Returns the requested order object\r\n *\r\n * @see {@link http://docs.metaco.apiary.io/#reference/orders/order-information/retreive-an-order} our online documentation.\r\n * @param {string} id - The order id\r\n * @param {requestCallback} callback - The callback that handles the response\r\n */\r\nMetacoClient.prototype.getOrder = function(id, callback) {\r\n    var url = extensions.formatString(\"orders/{0}\", id);\r\n    this.httpClient.doGet(url, callback);\r\n};\r\n\r\n/**\r\n * Requires Authentication\r\n * Submit a signed order\r\n * You have to sign each of your inputs of the selected order (you will get those details by fetching the orders)\r\n * Then encode the transaction in hexadecimal and send it here\r\n *\r\n * @see {@link http://docs.metaco.apiary.io/#reference/orders/order-information/submit-a-signed-order} our online documentation.\r\n * @param {string} id - The order id\r\n * @param {string} rawTransaction - The signed raw transaction encoded in hexadecimal\r\n * @param {requestCallback} callback - The callback that handles the response\r\n */\r\nMetacoClient.prototype.submitSignedOrder = function(id, rawTransaction, callback) {\r\n    var url = extensions.formatString(\"orders/{0}\", id);\r\n\r\n    var signedOrderToSubmit = {\r\n        raw: rawTransaction\r\n    };\r\n\r\n    this.httpClient.doPost(url, signedOrderToSubmit, callback);\r\n};\r\n\r\n/**\r\n * Requires Authentication\r\n * Cancel the specified order\r\n *\r\n * @see {@link http://docs.metaco.apiary.io/#reference/orders/order-information/cancel-an-order} our online documentation.\r\n * @param {string} id - The order id\r\n * @param {requestCallback} callback - The callback that handles the response\r\n */\r\nMetacoClient.prototype.cancelOrder = function(id, callback) {\r\n    var url = extensions.formatString(\"orders/{0}\", id);\r\n    this.httpClient.doDelete(url, callback);\r\n};\r\n\r\n/**\r\n * Requires Authentication\r\n * Create a Transaction using the provided parameters\r\n * This transaction will be created using the asset amount of the specified asset, this means that amountAsset an integer based on the divisibility of the asset as specified by v1/assets. (for example, USD divisibility is 2, if you want to transfer 5 USD, then amountAsset should be equal to 500). If you want to transfer 5 USD then amountAsset is 500.\r\n *\r\n * @param {number} amountAsset - Amount of the order in asset value.\r\n * @param {string} ticker - The full ticker identifier (MTC:USD) of the requested asset\r\n * @param {string} from - The address where the funds will be taken for the transaction\r\n * @param {string} to - The address which will receive the funds of the transaction\r\n * @param {string} change - (Optional, use null if you don't want to use it) This address will receive the change of the order if provided\r\n * @param {number} feePerKB - (Optional, use null if you don't want to use it) This will set the amount of fees per KB of the transaction\r\n * @param {requestCallback} callback - The callback that handles the response\r\n * @see {@link http://docs.metaco.apiary.io/#reference/transactions/raw-transaction/get-a-raw-transaction} our online documentation.\r\n */\r\nMetacoClient.prototype.createTransactionFromAssetAmount = function(amountAsset, ticker, from, to, change, feePerKB, callback) {\r\n\r\n    var url = \"transactions/raw?\";\r\n\r\n    if (amountAsset != null) {\r\n        url += extensions.formatString(\"amount_asset={0}&\", amountAsset);\r\n    }\r\n    if (ticker != null) {\r\n        url += extensions.formatString(\"ticker={0}&\", ticker);\r\n    }\r\n    if (from != null) {\r\n        url += extensions.formatString(\"from={0}&\", from);\r\n    }\r\n    if (to != null) {\r\n        url += extensions.formatString(\"to={0}&\", to);\r\n    }\r\n    if (change != null) {\r\n        url += extensions.formatString(\"change={0}&\", change);\r\n    }\r\n    if (feePerKB != null) {\r\n        url += extensions.formatString(\"feePerKB={0}&\", feePerKB);\r\n    }\r\n\r\n    url = url.slice(0, url.length - 1);\r\n\r\n    this.httpClient.doGet(url, callback);\r\n};\r\n\r\n/**\r\n * Requires Authentication\r\n * Create a Transaction using the provided parameters\r\n * This transaction will be created using the satoshi amount of the specified asset, this means that amountSatoshi is always satoshi-denominated. If you want to transfer 199000000 satoshi of USD then amountSatoshi is 199000000.\r\n *\r\n * @param {number} amountSatoshi - Amount of the order in satoshi value.\r\n * @param {string} ticker - The full ticker identifier (MTC:USD) of the requested asset\r\n * @param {string} from - The address where the funds will be taken for the transaction\r\n * @param {string} to - The address which will receive the funds of the transaction\r\n * @param {string} change - (Optional, use null if you don't want to use it) This address will receive the change of the order if provided\r\n * @param {number} feePerKB - (Optional, use null if you don't want to use it) This will set the amount of fees per KB of the transaction\r\n * @param {requestCallback} callback - The callback that handles the response\r\n * @see {@link http://docs.metaco.apiary.io/#reference/transactions/raw-transaction/get-a-raw-transaction} our online documentation.\r\n */\r\nMetacoClient.prototype.createTransactionFromSatoshiAmount = function(amountSatoshi, ticker, from, to, change, feePerKB, callback) {\r\n\r\n    var url = \"transactions/raw?\";\r\n\r\n    if (amountSatoshi != null) {\r\n        url += extensions.formatString(\"amount_satoshi={0}&\", amountSatoshi);\r\n    }\r\n    if (ticker != null) {\r\n        url += extensions.formatString(\"ticker={0}&\", ticker);\r\n    }\r\n    if (from != null) {\r\n        url += extensions.formatString(\"from={0}&\", from);\r\n    }\r\n    if (to != null) {\r\n        url += extensions.formatString(\"to={0}&\", to);\r\n    }\r\n    if (change != null) {\r\n        url += extensions.formatString(\"change={0}&\", change);\r\n    }\r\n    if (feePerKB != null) {\r\n        url += extensions.formatString(\"feePerKB={0}&\", feePerKB);\r\n    }\r\n\r\n    url = url.slice(0, url.length - 1);\r\n\r\n    this.httpClient.doGet(url, callback);\r\n};\r\n\r\n/**\r\n * Requires Authentication\r\n * Submit a signed transaction\r\n * You have to sign each of your inputs of the selected transaction (you will get those details when creating the transaction through Metaco)\r\n * Then encode the transaction in hexadecimal and send it here\r\n *\r\n\r\n * @param {string} rawTransaction - The signed raw transaction encoded in hexadecimal\r\n * @param {requestCallback} callback - The callback that handles the response\r\n * @see {@link http://docs.metaco.apiary.io/#reference/transactions/transaction-broadcast/broadcast-a-transaction} our online documentation.\r\n */\r\nMetacoClient.prototype.broadcastTransaction = function(rawTransaction, callback) {\r\n    var signedTransactionToSubmit = {\r\n        raw: rawTransaction\r\n    };\r\n\r\n    this.httpClient.doPost(\"transactions\", signedTransactionToSubmit, callback);\r\n};\r\n\r\n/**\r\n * Requires Authentication\r\n * Returns the current wallet state\r\n * Contains the current balances, the values and the transaction history\r\n *\r\n * @param {string} address - The wallet's address\r\n * @param {requestCallback} callback - The callback that handles the response\r\n * @see {@link http://docs.metaco.apiary.io/#reference/transactions/transaction-broadcast/fetch-wallet-information} our online documentation.\r\n */\r\nMetacoClient.prototype.getWalletDetails = function(address, callback) {\r\n    var url = extensions.formatString(\"transactions/{0}\", address);\r\n    this.httpClient.doGet(url, callback);\r\n};\r\n\r\n/**\r\n * For testing purposes only\r\n * On some requests, when you use the TestingMode of the client, you will get a DebugData, which will simplify the testing of the API and the client\r\n * As an example, a debugData could be the fake validationCode when your register an account.\r\n */\r\nMetacoClient.prototype.getLatestDebugData = function() {\r\n    return this.httpClient.getLatestDebugData();\r\n};\r\n\r\nmodule.exports = MetacoClient;","var MetacoErrors = require (\"./MetacoErrors\");\r\n\r\nvar ErrorHandler = {};\r\n\r\nvar httpOkRegex = /^2[0-9]{2}/;\r\nvar httpServerErrorRegex = /^2[0-9]{2}/;\r\n\r\nfunction hasError(httpCode, jsonContent) {\r\n    return !httpOkRegex.test(httpCode.toString());\r\n}\r\n\r\nfunction makeError(statusCode, content, originalError, errorType) {\r\n    return {\r\n        statusCode: statusCode,\r\n        content: content,\r\n        originalError: originalError,\r\n        errorType: errorType\r\n    }\r\n}\r\n\r\nErrorHandler.handleError = function (httpCode, textContent) {\r\n\r\n    var jsonContent = null;\r\n    var metacoErrorType = null;\r\n\r\n    try {\r\n        jsonContent = JSON.parse(textContent);\r\n    } catch (e) {\r\n        jsonContent = null;\r\n    }\r\n\r\n    if (!hasError(httpCode, jsonContent)) {\r\n        return null;\r\n    }\r\n\r\n    if (MetacoErrors.values.hasOwnProperty(jsonContent && jsonContent !== null && jsonContent.metaco_error)) {\r\n        metacoErrorType = MetacoErrors.keys[MetacoErrors.values[jsonContent.metaco_error]];\r\n    } else {\r\n        if (httpCode == 404) {\r\n            metacoErrorType = MetacoErrors.keys.NOT_FOUND;\r\n        } else if (httpCode == 401) {\r\n            metacoErrorType = MetacoErrors.keys.UNAUTHORIZED;\r\n        } else if (!httpServerErrorRegex.test(httpCode.toString())) {\r\n            metacoErrorType = MetacoErrors.keys.SERVER_ERROR;\r\n        } else {\r\n            metacoErrorType = MetacoErrors.keys.UNKNOWN_ERROR;\r\n        }\r\n    }\r\n\r\n    return makeError(httpCode, textContent, jsonContent, metacoErrorType);\r\n};\r\n\r\nmodule.exports = ErrorHandler;","var keys = {\r\n\r\n    INVALID_INPUT: \"invalid_input\",\r\n    API_CALLS_QUOTA_EXCEEDED: \"api_calls_quota_exceeded\",\r\n    SMS_SENDING_FAILED: \"sms_sending_failed\",\r\n    PHONE_CONFIRMATION_NOT_FOUND: \"phone_confirmation_not_found\",\r\n    INVALID_CONFIRMATION_CODE: \"invalid_confirmation_code\",\r\n    ORDER_NOT_FOUND: \"order_not_found\",\r\n    NOT_ENOUGH_FUNDS: \"not_enough_funds\",\r\n    ORDER_TOO_SMALL: \"order_too_small\",\r\n    ORDER_COUNT_LIMIT_EXCEEDED: \"order_count_limit_exceeded\",\r\n    YEARLY_TRANSACTION_QUOTA_EXCEEDED: \"yearly_transaction_quota_exceeded\",\r\n    MAXIMUM_TRANSACTION_AMOUNT_EXCEEDED: \"maximum_transaction_amount_exceeded\",\r\n    ORDER_NOT_CANCELLABLE: \"order_not_cancellable\",\r\n    UNAUTHORIZED: \"unauthorized\",\r\n    NOT_FOUND: \"notfound\",\r\n    SERVER_ERROR: \"servererror\",\r\n    UNKNOWN_ERROR: \"unknownerror\"\r\n};\r\n\r\nfunction reverseKeys(original) {\r\n    var values = {};\r\n\r\n    for (var key in keys) {\r\n        if (keys.hasOwnProperty(key)) {\r\n            values[original[key]] = key;\r\n        }\r\n    }\r\n\r\n    return values;\r\n}\r\n\r\nvar values = reverseKeys(keys);\r\n\r\nmodule.exports = {\r\n    keys: keys,\r\n    values: values\r\n};","var ErrorHandler = require(\"../errors/ErrorHandler\");\r\n\r\nfunction BrowserHttpClient(metacoApiUrl, metacoApiId, metacoApiKey, metacoTestingMode) {\r\n    this.metacoApiId = metacoApiId;\r\n    this.metacoApiKey = metacoApiKey;\r\n    this.metacoApiUrl = metacoApiUrl;\r\n    this.metacoTestingMode = metacoTestingMode;\r\n    this.latestDebugData = null;\r\n\r\n    this.handleDebugData = function(xhr) {\r\n        this.latestDebugData = null;\r\n        this.latestDebugData = xhr.getResponseHeader('X-Metaco-DebugData');\r\n    };\r\n\r\n    this.getAbsoluteUri = function (relativeUri) {\r\n        return this.metacoApiUrl + relativeUri;\r\n    };\r\n\r\n    this.getHeaders = function () {\r\n        var headers = [];\r\n\r\n        headers.push({name: \"X-Requested-With\", value: \"XMLHttpRequest\"});\r\n        headers.push({name: \"Content-type\", value: \"application/json\"});\r\n        headers.push({name: \"Accept\", value: \"application/json\"});\r\n\r\n        if (this.metacoApiId && this.metacoApiId !== \"\" &&\r\n            this.metacoApiKey && this.metacoApiKey !== \"\") {\r\n            headers.push({name: \"X-Metaco-Id\", value: this.metacoApiId});\r\n            headers.push({name: \"X-Metaco-Key\", value: this.metacoApiKey});\r\n        }\r\n\r\n        if (this.metacoTestingMode) {\r\n            headers.push({name: \"X-Metaco-Debug\", value: true});\r\n        }\r\n\r\n        return headers;\r\n    };\r\n\r\n    this.doAjaxRequest = function (type, relativeUrl, callback, dataObject) {\r\n        try {\r\n\r\n            var _this = this;\r\n\r\n            var headers = this.getHeaders();\r\n            var absoluteUrl = this.getAbsoluteUri(relativeUrl);\r\n            var jsonData = JSON.stringify(dataObject);\r\n\r\n            var x = new(window.XMLHttpRequest || ActiveXObject)('MSXML2.XMLHTTP.3.0');\r\n\r\n            x.open(type, absoluteUrl, 1);\r\n\r\n            for(var header in headers) {\r\n                if (headers.hasOwnProperty(header)) {\r\n                    x.setRequestHeader(headers[header].name, headers[header].value);\r\n                }\r\n            }\r\n\r\n            x.onreadystatechange = function () {\r\n                if (x.readyState > 3) {\r\n                    var text = x.responseText;\r\n\r\n                    var error = ErrorHandler.handleError(x.status, text);\r\n\r\n                    _this.handleDebugData(x);\r\n\r\n                    if (error) {\r\n                        callback(error, null);\r\n                    } else {\r\n                        var json = true;\r\n\r\n                        try {\r\n                            json = JSON.parse(text);\r\n                        } catch(e) {}\r\n\r\n                        callback(error, json);\r\n                    }\r\n                }\r\n            };\r\n\r\n            x.send(jsonData)\r\n\r\n        } catch (e) {\r\n            var error = ErrorHandler.handleError(0, e.toString());\r\n            callback(error, null);\r\n        }\r\n    }\r\n}\r\n\r\nBrowserHttpClient.prototype.doGet = function (relativeUrl, callback) {\r\n    return this.doAjaxRequest(\"GET\", relativeUrl, callback, null);\r\n};\r\n\r\nBrowserHttpClient.prototype.doPost = function (relativeUrl, dataObject, callback) {\r\n    return this.doAjaxRequest(\"POST\", relativeUrl, callback, dataObject);\r\n};\r\n\r\nBrowserHttpClient.prototype.doDelete = function (relativeUrl, callback) {\r\n    return this.doAjaxRequest(\"DELETE\", relativeUrl, callback, null);\r\n};\r\n\r\nBrowserHttpClient.prototype.getLatestDebugData = function () {\r\n    return this.latestDebugData;\r\n};\r\n\r\nmodule.exports = BrowserHttpClient;","var MetacoClientBuilderFactory = require (\"./MetacoClientBuilderFactory\");\r\nvar HttpClient = require(\"./http/BrowserHttpClient\");\r\nvar MetacoErrors = require(\"./errors/MetacoErrors\");\r\n\r\n\r\nfunction GetClientBuilder() {\r\n    return new MetacoClientBuilderFactory().makeClientBuilderWithHttpClient(HttpClient);\r\n}\r\n\r\n(function (__window__) {\r\n    __window__.metaco = __window__.metaco || {};\r\n    __window__.metaco.GetClientBuilder = GetClientBuilder;\r\n    __window__.metaco.MetacoErrors = MetacoErrors.keys;\r\n}(window));","var extensions = {};\r\n\r\nextensions.formatString = function(template) {\r\n    for (var i = 0; i < arguments.length - 1; i++) {\r\n        var regexp = new RegExp('\\\\{'+i+'\\\\}', 'gi');\r\n        template = template.replace(regexp, arguments[i + 1]);\r\n    }\r\n    return template;\r\n};\r\n\r\nmodule.exports = extensions;"]}